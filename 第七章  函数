1、函数的定义：
		返回值类型 函数名（形式参数列表）
{
函数代码
}
函数名：
-函数名尽量有意义，为函数功能的描述
-函数名命名需满足C语言合法标识符的要求
-C语言中不允许函数名重复
形式参数列表：
	-形式参数的个数为任意多个，（>=0）
	-如果没有参数时，可以为空，也可以写void
	-形式参数包含参数的类型及参数的名称
-形式参数之间通过逗号链接
返回值类型：
	-返回值 为 0或1个
	-如果没有返回值时，返回值类型写void
	-如果有返回值，返回值类型要与函数体中的return语句类型相匹配
	-函数体中return语句后可接字面值、变量、表达式，如果无返回值，直接写return
2、函数调用：
	函数名（实际参数列表）
-去使用已经定义的函数实现特定功能
-函数调用实际参数列表在个数、类型、顺序上都要与函数的形式参数列表完全匹配。
-函数调用会完成实际参数往形式参数的赋值操作
	-函数调用的返回值
  		  - 可以用来赋值
   【例】：int sum = myAdd(100, 222);
        - 也可以直接使用
   【例】：printf("%d\n", myAdd(100, 222)); 
3、函数的声明（函数的前置声明）：
函数头 + 分号
-告诉编译器函数的相关信息
	函数名、形式参数列表、返回值类型
-声明中的形式参数列表可以省略参数名
-如果函数定义在家函数调用语句之前，那么不需要函数声明，函数定义附带函数声明作用
4、被调函数：被调用的函数
   主调函数：调用语句所在函数
   实参——>形参
-	值传递
-	地址传递（本质上还是值传递）
可以将主调函数中变量的地址传递给被调函数的形参，来达到在被调函数中修改主调函数中变量的目的。
5、C语言中不能直接使用数组作为参数，但是可以通过
    传递数组首元素地址和数组长度来达到传递数组的
    效果。
    【下面方式，本质上是 int * arr
     void fun(int arr[4]) ...】
6、递归：函数直接或间接地调用自身的技巧
	1）确定递归公式，问题规模化小的公式；
	2）确定递归的边界，递归的极小规模问题；
	3）先判断边界，再进行递归；
	4）递归执行代价过大，效率不够高
7、生存周期：变量所拥有的内存的时间，从定义变量系统分配内存，到变量内存被系统回收。
- 动态生存周期：变量随代码执行而创建，随代码执行而销毁
- 静态生存周期：程序一运行（main函数执行前）就创建，程序结束再被销毁
  - 全局变量：不属于任何具体函数，属于整个源文件。
				 当前源文件任意位置都可以访问。
- 初始化：静态生存周期的变量，即使没有进行初始化也会默认初始化为0。
8、作用域：变量可以有效使用的范围。
	- 变量的作用域一般是变量定义语句所属代码段
9、static:将动态的生存周期变为静态生存周期。
			 仅仅改变生存周期，不改变作用域。
- static修饰全局变量，表示此全局变量只能在当前源文件中使用，其他源文件不允许使用。
10、typedef:给一个已知的类型起一个别名
11、const限定符“限定”对象具有只读属性，即对象是不可修改的。
12、内存区域：
	 - 栈区：存放动态生存周期的变量。
	 - 堆区：由程序员动态申请，动态内存分配。
- 常量只读区：字符串字面值（只能读不能写）。
- 静态全局区：存放静态生存周期的变量。
- 代码区：存放代码。
13、动态内存分配：由程序员根据程序需求，动态的在堆区申请、释放内存。（需引入c语言标准库 #include<stdlib.h>）
	 void * malloc(int size)
	 - 传给他所需要的内存的大小（字节数），返回申请到的内存首地址。
	 - 返回的是通用指针，一般都需要进行显示类型转换(强制类型转换)。
	 - malloc可能会返回NULL，表示申请内存失败。
	 - free(void * p)
		- 将申请到的内存首地址传给free方法，完成内存释放。
		- 内存释放后，不允许再去使用。
	 - void * calloc(int num,int size)
		- num:元素个数
		- size:元素大小
		- 返回：申请到的内存首地址
		- malloc 只负责分配内存，不负责清理
		- calloc 在分配内存的同时完成清0操作
14、函数指针：指向函数的指针
